use crate::ast::*;
use std::str::FromStr;

grammar;

pub Program: Program = Item* => Program {
    items: <>.into_iter().flatten().collect()
};

Item: Option<Item> = {
    Comment => None,
    ConstantDef => Some(Item::ConstantDef(<>)),
    Directive => Some(Item::Directive(<>)),
    <Identifier> ":" => Some(Item::Label(<>)),
    Instruction => Some(Item::Instruction(<>)),
};

Comment: () = r"#.*";

Expr: Expr = {
    <left:Expr> "+" <right:FactorExpr> => Expr::Calculated {
        operation: Operation::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:Expr> "-" <right:FactorExpr> => Expr::Calculated {
        operation: Operation::Subtract,
        left: Box::new(left),
        right: Box::new(right),
    },
    FactorExpr,
};

FactorExpr: Expr = {
    <left:FactorExpr> "*" <right:TerminalExpr> => Expr::Calculated {
        operation: Operation::Multiply,
        left: Box::new(left),
        right: Box::new(right),
    },
    <left:FactorExpr> "/" <right:TerminalExpr> => Expr::Calculated {
        operation: Operation::Divide,
        left: Box::new(left),
        right: Box::new(right),
    },
    "-" <expr:TerminalExpr> => Expr::Calculated {
        operation: Operation::Multiply,
        left: Box::new(Expr::Number(-1)),
        right: Box::new(expr),
    },
    TerminalExpr,
};

TerminalExpr: Expr = {
    Number => Expr::Number(<>),
    Identifier => Expr::Constant(<>),
    "(" <Expr> ")",
};

Number: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();

Identifier: String = r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string();

String: String = r#""([^\\"]|\\.)*""# => <>.strip_prefix('\"').unwrap().strip_suffix('\"').unwrap().to_string();

ConstantDef: ConstantDef = <name:Identifier> "=" <value:Expr> => ConstantDef { name, value };

Directive: Directive = {
    ".text" => Directive::Text,
    ".globl" <name:Identifier> => Directive::Global { name },
    ".data" => Directive::Data,
    ".align" <boundary:Expr> => Directive::Align { boundary },
    ".space" <size:Expr> => Directive::Space { size },
    ".word" <count:Expr> => Directive::Word { count },
    ".asciiz" <string:String> => Directive::Asciiz { string },
};

Instruction: Instruction = {
    <op_code:RTypeOp> <rd:Register> "," <rs:Register> "," <rt:Register> => Instruction::RType { op_code, rd, rs, rt },
    <op_code:ITypeOp> <rs:Register> "," <rt:Register> "," <immediate:Expr> => Instruction::IType { op_code, rs, rt, immediate },
    <op_code:StorageITypeOp> <rt:Register> "," <immediate:Expr> "(" <rs:Register> ")" => Instruction::IType { op_code, rs, rt, immediate },
    PseudoInstruction => Instruction::Pseudo(<>),
};

PseudoInstruction: PseudoInstruction = {
    "li" <rd:Register> "," <value:Expr> => PseudoInstruction::LoadImmediate { rd, value },
    "la" <rd:Register> "," <label:Identifier> => PseudoInstruction::LoadAddress { rd, label },
};

RTypeOp: RTypeOp = {
    "add" => RTypeOp::Add,
};

ITypeOp: ITypeOp = {
    "addi" => ITypeOp::Addi,
};

StorageITypeOp: ITypeOp = {
    "sw" => ITypeOp::Sw
};

Register: Register = {
    "$" <Number> => Register::Number(<> as u8),
    "$" <Identifier> => Register::Name(<>),
};
