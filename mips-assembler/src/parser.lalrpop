use crate::ast::*;
use std::str::FromStr;

grammar;

Comma<T>: Vec<T> = {
    <mut items:(<T> ",")*> <last:T?> => {
        items.extend(last);
        items
    }
};

pub Program: Program = {
    <mut items:("\n"* <Item> "\n")*> <last:("\n"* <Item?>)> => Program {
        items: {
            items.extend(last);
            items
        }
    }
};

Item: Item = {
    ConstantDef => Item::ConstantDef(<>),
    Directive => Item::Directive(<>),
    <Identifier> ":" => Item::Label(<>),
    Instruction => Item::Instruction(<>),
};

Expr: Expr = {
    #[precedence(level = "1")]
    Number => Expr::Number(<>),
    #[precedence(level = "1")]
    Identifier => Expr::Constant(<>),
    #[precedence(level = "1")]
    "(" <Expr> ")",
    #[precedence(level = "1")]
    "-" <expr:Expr> => Expr::Negated(Box::new(expr)),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <left:Expr> "*" <right:Expr> => Expr::Calculated {
        operation: Operation::Multiply,
        left: Box::new(left),
        right: Box::new(right),
    },
    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <left:Expr> "/" <right:Expr> => Expr::Calculated {
        operation: Operation::Divide,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <left:Expr> "+" <right:Expr> => Expr::Calculated {
        operation: Operation::Add,
        left: Box::new(left),
        right: Box::new(right),
    },
    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <left:Expr> "-" <right:Expr> => Expr::Calculated {
        operation: Operation::Subtract,
        left: Box::new(left),
        right: Box::new(right),
    },
};

Number: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();

Identifier: String = r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string();

String: String = r#""([^\\"]|\\.)*""# => <>.strip_prefix('\"').unwrap().strip_suffix('\"').unwrap().to_string();

ConstantDef: ConstantDef = <name:Identifier> "=" <value:Expr> => ConstantDef { name, value };

Directive: Directive = {
    ".text" => Directive::Text,
    ".globl" <label:Identifier> => Directive::Global { label },
    ".data" => Directive::Data,
    ".align" <boundary:Expr> => Directive::Align { boundary },
    ".space" <size:Expr> => Directive::Space { size },
    ".word" <values:Comma<Expr>> => Directive::Word { values },
    ".asciiz" <string:String> => Directive::Asciiz { string },
};

Instruction: Instruction = {
    <op_code:RTypeOpRdRsRt> <rd:Register> "," <rs:Register> "," <rt:Register> => Instruction::RType { op_code, rd, rs, rt },
    <op_code:RTypeOpRs> <rs:Register> => Instruction::RType { op_code, rs, rd: Register::Number(0), rt: Register::Number(0) },
    <op_code:ITypeOpRtRs> <rt:Register> "," <rs:Register> "," <immediate:Expr> => Instruction::IType { op_code, rt, rs, immediate },
    <op_code:ITypeOpRsRt> <rs:Register> "," <rt:Register> "," <immediate:Expr> => Instruction::IType { op_code, rs, rt, immediate },
    <op_code:StorageITypeOp> <rt:Register> "," <immediate:Expr> "(" <rs:Register> ")" => Instruction::IType { op_code, rs, rt, immediate },
    <op_code:JTypeOp> <label:Expr> => Instruction::JType { op_code, label },
    "syscall" => Instruction::Syscall,
    PseudoInstruction => Instruction::Pseudo(<>),
};

PseudoInstruction: PseudoInstruction = {
    "li" <rd:Register> "," <value:Expr> => PseudoInstruction::LoadImmediate { rd, value },
    "la" <rd:Register> "," <label:Identifier> => PseudoInstruction::LoadAddress { rd, label },
    "move" <rt:Register> "," <rs:Register> => PseudoInstruction::Move { rt, rs },
};

RTypeOpRdRsRt: RTypeOp = {
    "add" => RTypeOp::Add,
};

RTypeOpRs: RTypeOp = {
    "jr" => RTypeOp::Jr,
};

ITypeOpRtRs: ITypeOp = {
    "addi" => ITypeOp::Addi,
    "slti" => ITypeOp::Slti,
};

ITypeOpRsRt: ITypeOp = {
    "beq" => ITypeOp::Beq,
};

StorageITypeOp: ITypeOp = {
    "sw" => ITypeOp::Sw,
    "lw" => ITypeOp::Lw,
};

JTypeOp: JTypeOp = {
    "j" => JTypeOp::Jump,
    "jal" => JTypeOp::Jal,
};

Register: Register = {
    "$" <Number> => Register::Number(<> as u8),
    "$" <Identifier> => Register::Name(<>),
};

match {
    // Ignore comments
    r"#[^\n]*" => { },

    // Ignore whitespace (but keep newlines)
    "\t" => { },
    " " => { },

    // Catch-all for the rest of the terminals
    _
}
