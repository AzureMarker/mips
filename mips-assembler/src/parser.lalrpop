use crate::ast::*;
use mips_types::constants::{BCOND_RT_BGEZ, BCOND_RT_BGEZAL, BCOND_RT_BLTZ, BCOND_RT_BLTZAL};
use std::str::FromStr;

grammar;

Comma<T>: Vec<T> = {
    <mut items:(<T> ",")*> <last:T?> => {
        items.extend(last);
        items
    }
};

pub Program: Program = {
    <items:("\n"* <Item>)*> "\n"* => Program { items }
};

Item: Item = {
    <ConstantDef> "\n" => Item::ConstantDef(<>),
    <Directive> "\n" => Item::Directive(<>),
    <Identifier> ":" => Item::Label(<>),
    <Instruction> "\n" => Item::Instruction(<>),
};

Expr: Expr = {
    #[precedence(level = "1")]
    Number => Expr::Number(<>),
    #[precedence(level = "1")]
    Identifier => Expr::Constant(<>),
    #[precedence(level = "1")]
    "(" <Expr> ")",
    #[precedence(level = "1")]
    "-" <expr:Expr> => Expr::Negated(Box::new(expr)),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <left:Expr> <operation:ExprOperation2> <right:Expr> => Expr::Calculated {
        operation,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <left:Expr> <operation:ExprOperation3> <right:Expr> => Expr::Calculated {
        operation,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "4")]
    #[assoc(side = "left")]
    <left:Expr> <operation:ExprOperation4> <right:Expr> => Expr::Calculated {
        operation,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "5")]
    #[assoc(side = "left")]
    <left:Expr> "&" <right:Expr> => Expr::Calculated {
        operation: Operation::BitwiseAnd,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "6")]
    #[assoc(side = "left")]
    <left:Expr> "^" <right:Expr> => Expr::Calculated {
        operation: Operation::BitwiseXor,
        left: Box::new(left),
        right: Box::new(right),
    },

    #[precedence(level = "7")]
    #[assoc(side = "left")]
    <left:Expr> "|" <right:Expr> => Expr::Calculated {
        operation: Operation::BitwiseOr,
        left: Box::new(left),
        right: Box::new(right),
    },
};

ExprOperation2: Operation = {
    "*" => Operation::Multiply,
    "/" => Operation::Divide,
};

ExprOperation3: Operation = {
    "+" => Operation::Add,
    "-" => Operation::Subtract,
};

ExprOperation4: Operation = {
    ">>" => Operation::BitwiseShiftRight,
    "<<" => Operation::BitwiseShiftLeft
};

RepeatedExpr: RepeatedExpr = <expr:Expr> <times:(":" <Expr>)?>
    => RepeatedExpr { expr, times: times.unwrap_or(Expr::Number(1)) };

Number: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();

Identifier: String = r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string();

String: String = r#""([^\\"]|\\.)*""# => {
    let s = <>;
    s[1..s.len()-1].to_string()
};

ConstantDef: ConstantDef = <name:Identifier> "=" <value:Expr> => ConstantDef { name, value };

Directive: Directive = {
    ".text" => Directive::Text,
    ".globl" <label:Identifier> => Directive::Global { label },
    ".data" => Directive::Data,
    ".align" <boundary:Expr> => Directive::Align { boundary },
    ".space" <size:Expr> => Directive::Space { size },
    ".word" <values:Comma<RepeatedExpr>> => Directive::Word { values },
    ".asciiz" <string:String> => Directive::Asciiz { string },
};

Instruction: Instruction = {
    <op_code:RTypeOpRdRsRt> <rd:Register> "," <rs:Register> "," <rt:Register>
        => Instruction::RType { op_code, rd, rs, rt, shift: Expr::Number(0) },
    <op_code:RTypeOpRdRtRs> <rd:Register> "," <rt:Register> "," <rs:Register>
        => Instruction::RType { op_code, rd, rs, rt, shift: Expr::Number(0) },
    <op_code:RTypeOpRdRtSh> <rd:Register> "," <rt:Register> "," <shift:Expr>
        => Instruction::RType { op_code, rd, rs: Register::Number(0), rt, shift },
    <op_code:RTypeOpRsRt> <rs:Register> "," <rt:Register>
        => Instruction::RType { op_code, rd: Register::Number(0), rs, rt, shift: Expr::Number(0) },
    <op_code:RTypeOpRs> <rs:Register>
        => Instruction::RType { op_code, rs, rd: Register::Number(0), rt: Register::Number(0), shift: Expr::Number(0) },
    <op_code:RTypeOpRd> <rd:Register>
        => Instruction::RType { op_code, rs: Register::Number(0), rd, rt: Register::Number(0), shift: Expr::Number(0) },
    <op_code:ITypeOpRtRs> <rt:Register> "," <rs:Register> "," <immediate:Expr>
        => Instruction::IType { op_code, rt, rs, immediate },
    <op_code:ITypeOpRsRt> <rs:Register> "," <rt:Register> "," <immediate:Expr>
        => Instruction::IType { op_code, rs, rt, immediate },
    <op_data:ITypeOpRs> <rs:Register> "," <immediate:Expr>
        => Instruction::IType { op_code: op_data.0, rs, rt: Register::Number(op_data.1), immediate },
    <op_code:StorageITypeOp> <rt:Register> "," <immediate:Expr> "(" <rs:Register> ")"
        => Instruction::IType { op_code, rs, rt, immediate },
    <op_code:JTypeOp> <label:Expr>
        => Instruction::JType { op_code, label },
    "syscall" => Instruction::RType {
        op_code: RTypeOp::Syscall,
        rd: Register::Number(0),
        rs: Register::Number(0),
        rt: Register::Number(0),
        shift: Expr::Number(0)
    },
    "noop" => Instruction::RType {
        op_code: RTypeOp::Sll,
        rd: Register::Number(0),
        rs: Register::Number(0),
        rt: Register::Number(0),
        shift: Expr::Number(0)
    },
    PseudoInstruction => Instruction::Pseudo(<>),
};

PseudoInstruction: PseudoInstruction = {
    "li" <rd:Register> "," <value:Expr> => PseudoInstruction::LoadImmediate { rd, value },
    "la" <rd:Register> "," <label:Identifier> => PseudoInstruction::LoadAddress { rd, label },
    "move" <rt:Register> "," <rs:Register> => PseudoInstruction::Move { rt, rs },
};

RTypeOpRdRsRt: RTypeOp = {
    "add" => RTypeOp::Add,
    "addu" => RTypeOp::Addu,
    "and" => RTypeOp::And,
    "slt" => RTypeOp::Slt,
    "sltu" => RTypeOp::Sltu,
    "sub" => RTypeOp::Sub,
    "subu" => RTypeOp::Subu,
    "xor" => RTypeOp::Xor,
    "nor" => RTypeOp::Nor,
};

RTypeOpRdRtRs: RTypeOp = {
    "srav" => RTypeOp::Srav,
    "sllv" => RTypeOp::Sllv,
    "srlv" => RTypeOp::Srlv,
};

RTypeOpRdRtSh: RTypeOp = {
    "sll" => RTypeOp::Sll,
    "sra" => RTypeOp::Sra,
    "srl" => RTypeOp::Srl,
};

RTypeOpRsRt: RTypeOp = {
    "div" => RTypeOp::Div,
    "divu" => RTypeOp::Divu,
    "mult" => RTypeOp::Mult,
    "multu" => RTypeOp::Multu,
};

RTypeOpRs: RTypeOp = {
    "jr" => RTypeOp::Jr,
    "jalr" => RTypeOp::Jalr,
    "mthi" => RTypeOp::Mthi,
    "mtlo" => RTypeOp::Mtlo,
};

RTypeOpRd: RTypeOp = {
    "mfhi" => RTypeOp::Mfhi,
    "mflo" => RTypeOp::Mflo,
};

ITypeOpRtRs: ITypeOp = {
    "addi" => ITypeOp::Addi,
    "addiu" => ITypeOp::Addiu,
    "andi" => ITypeOp::Andi,
    "slti" => ITypeOp::Slti,
    "sltiu" => ITypeOp::Sltiu,
    "xori" => ITypeOp::Xori,
};

ITypeOpRsRt: ITypeOp = {
    "beq" => ITypeOp::Beq,
    "bne" => ITypeOp::Bne,
};

// The u8 is rt, which distinguishes some of the instructions
ITypeOpRs: (ITypeOp, u8) = {
    "bgez" => (ITypeOp::Bcond, BCOND_RT_BGEZ),
    "bgezal" => (ITypeOp::Bcond, BCOND_RT_BGEZAL),
    "bgtz" => (ITypeOp::Bgtz, 0),
    "blez" => (ITypeOp::Blez, 0),
    "bltz" => (ITypeOp::Bcond, BCOND_RT_BLTZ),
    "bltzal" => (ITypeOp::Bcond, BCOND_RT_BLTZAL),
};

StorageITypeOp: ITypeOp = {
    "sb" => ITypeOp::Sb,
    "sh" => ITypeOp::Sh,
    "sw" => ITypeOp::Sw,
    "swl" => ITypeOp::Swl,
    "swr" => ITypeOp::Swr,
    "lb" => ITypeOp::Lb,
    "lbu" => ITypeOp::Lbu,
    "lh" => ITypeOp::Lh,
    "lhu" => ITypeOp::Lhu,
    "lw" => ITypeOp::Lw,
    "lwl" => ITypeOp::Lwl,
    "lwr" => ITypeOp::Lwr,
};

JTypeOp: JTypeOp = {
    "j" => JTypeOp::Jump,
    "jal" => JTypeOp::Jal,
};

Register: Register = {
    "$" <Number> => Register::Number(<> as u8),
    "$" <Identifier> => Register::Name(<>),
};

match {
    // Ignore comments
    r"#[^\n]*" => { },

    // Ignore whitespace (but keep newlines)
    "\t" => { },
    " " => { },

    // Catch-all for the rest of the terminals
    _
}
